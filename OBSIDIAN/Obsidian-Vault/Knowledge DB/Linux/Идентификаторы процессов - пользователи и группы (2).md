#linux #console 

### В [[Идентификаторы процессов - пользователи и группы|прошлый раз]] мы посмотрели на первые 3 базовых идентификатора: RUID, EUID и SUID. Сегодня пойдем дальше и добьем последние 2:

1) ID пользователя и группы файловой системы (FSUID);
2) ID дополнительных групп (supplementary group);

ID пользователя и группы файловой системы (FSUID)

В Linux для определения прав доступа к файлам, применяются не пользовательские и групповые EUID, а соответствующие ID файловой системы (FSUID). Они используются в этом качестве наряду с идентификаторами дополнительных групп, описанных ниже.

Обычно идентификаторы файловой системы имеют те же значения, что и соответствующие действующие собраты. Более того, каждый раз при изменении EUID ядро также автоматически изменяет и FSUID, присваивая ему аналогичное значение:


```sh
$ ps -eo pid,uid,euid,suid,fsuid,comm
    PID   UID  EUID  SUID FSUID COMMAND
      1     0     0     0     0 systemd
```


Однако, никто не запрещает вам изменить ID файловой системы и сделать его отличным от действующих ID. Реализовать это можно через вызовы setfsuid и setfsgid:


```sh
#include <sys/fsuid.h>

int setfsuid(uid_t fsuid);
int setfsgid(gid_t fsgid);
```


А зачем в Linux вообще предоставляются идентификаторы файловой системы и при каких обстоятельствах нам могут понадобиться разные значения для EUID и FSUID?

Причины главным образом имеют исторические корни. Идентификаторы файловой системы впервые появились в Linux 1.2. В этой версии ядра один процесс мог отправлять сигнал другому, лишь если EUID отправителя совпадал с RUID или EUID целевого процесса.

Это повлияло на некоторые программы, например на программу сервера Linux NFS (Network File System), которой нужна была возможность доступа к файлам, как будто у нее есть действующие идентификаторы соответствующих клиентских процессов.

Но, если бы NFS-сервер изменял свой действующий идентификатор пользователя, он стал бы уязвим от сигналов непривилегированных пользовательских процессов.

Для предотвращения этой возможности были придуманы отдельные FSUID. Оставляя неизмененными свои действующие идентификаторы, но изменяя идентификаторы файловой системы, NFS-сервер может выдавать себя за другого пользователя с целью обращения к файлам без уязвимости от сигналов пользовательских процессов.

Начиная с версии ядра 2.0, приняты правила относительно разрешений на отправку сигналов, в результате чего, наличие FSUID утратило свою актуальность. В наше время ID файловой системы считаются некой экзотикой и, как правило, совпадают по значениям с EUID.

ID дополнительных групп (supplementary group)

В ранних реализациях unix, процесс мог принадлежать только к одной группе, прописанной в "/etc/passwd". Сейчас же можно принадлежать сразу к нескольким.

Новый процесс наследует эти идентификаторы от своего родительского процесса. Оболочка входа в систему получает свои дополнительные идентификаторы групп из файла групп системы "/etc/group":


```sh
$ cat /etc/group | grep xodefender
adm:x:4:syslog,xodefender
cdrom:x:24:xodefender
sudo:x:27:xodefender
dip:x:30:xodefender
video:x:44:xodefender
```


Как уже ранее отмечалось, эти идентификаторы используются в совокупности с EUID и FSUID для определения полномочий по доступу к файлам, IPC-объектам и другим системным ресурсам.

Процесс может получить список ID дополнительных групп с помощь getgroups, и изменить этот список с помощью setgroups:


```c
#include <unistd.h>
int getgroups(int size, gid_t list[]);

#include <grp.h>
int setgroups(size_t size, const gid_t *_Nullable list);
```
