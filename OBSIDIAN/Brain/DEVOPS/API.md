_API (Application programming interface)_ — это контракт, который предоставляет программа. «Ко мне можно обращаться так и так, я обязуюсь делать то и это».  
  
Если переводить на русский, это было бы слово «договор». Договор между двумя сторонами, как договор на покупку машины:  
  

- мои обязанности — внести такую то сумму,
- обязанность продавца — дать машину.

  
Перевести можно, да. Но никто так не делает ¯\_(ツ)_/¯  
  
Все используют слово «контракт». Так принято. К тому же это слово входит в название стиля разработки:  
  

- Code first — сначала пишем код, потом по нему генерируем контракт
- Contract first — сначала создаем контракт, потом по нему пишем или генерируем код (в этой статье я буду говорить именно об этом стиле)

  
Мы же не говорим «контракт на продажу машины»? Вот и разработчики не говорят «договор». Негласное соглашение.  
  

## API — набор функций

  
Когда вы покупаете машину, вы составляете договор, в котором прописываете все важные для вас пункты. Точно также и между программами должны составляться договоры. Они указывают, как к той или иной программе можно обращаться.  
  
Соответственно, API отвечает на вопрос “Как ко мне, к моей системе можно обратиться?”, и включает в себя:  
  

- саму операцию, которую мы можем выполнить,
- данные, которые поступают на вход,
- данные, которые оказываются на выходе (контент данных или сообщение об ошибке).

  
![image](https://habrastorage.org/r/w1560/webt/2x/rv/qa/2xrvqa5qt01hubxsaytf2sgi_ia.png)  
  
Тут вы можете мне сказать:  
  
— Хмм, погоди. Операция, данные на входе, данные на выходе — как-то всё это очень сильно похоже на описание функции!  
  
_Если вы когда-то сталкивались с разработкой или просто изучали язык программирования, вы наверняка знаете, что такое функция. Фактически у нас есть данные на входе, есть данные на выходе, и некая магия, которая преобразует одно в другое._  
  
И да! Вы будете правы в том, что определения похожи. Почему? Да потому что API — это набор функций. Это может быть одна функция, а может быть много.  
  
![image](https://habrastorage.org/r/w1560/webt/sn/jw/46/snjw46wwnvuatj0wkghyuueofao.png)  
  

## Как составляется набор функций

  
Да без разницы как. Как разработчик захочет, так и сгруппирует. Например, можно группировать API по функционалу. То есть:  
  

- отдельно API для входа в систему, где будет регистрация и авторизация;
- отдельно API для отчетности — отчет 1, отчет 2, отчет 3… отчет N. Для разных отчетов у нас разные формулы = разные функции. И все мы их собираем в один набор, api для отчетности.
- отдельно API платежек — для работы с каждым банком своя функция.
- ...

  
![image](https://habrastorage.org/r/w1560/webt/xh/4z/oz/xh4zozptcyhurgnczngm9uqhje0.png)  
  
Можно не группировать вообще, а делать одно общее API.  
  
Можно сделать одно общее API, а остальные «под заказ». Если у вас коробочный продукт, то в него обычно входит набор стандартных функций. А любые хотелки заказчиков выносятся отдельно.  
  
![image](https://habrastorage.org/r/w1560/webt/lf/jh/o6/lfjho6yakkb1jciqvtti0wonj00.png)  
  
Получается, что в нашей системе есть несколько разных API, на каждое из которых у нас написан контракт. В каждом контракте четко прописано, какие операции можно выполнять, какие функции там будут  
  
![image](https://habrastorage.org/r/w1560/webt/xo/nv/29/xonv293kj3r1fiwniobwatdn8f0.png)  
  
И конечно, функции можно переиспользовать. То есть одну и ту же функцию можно включать в разные наборы, в разные апи. Никто этого не запрещает.  
  
![image](https://habrastorage.org/r/w1560/webt/uj/hm/wa/ujhmwa-iv-okyrifyzqpnu3acsw.png)  
  
Получается, что разработчик придумывает, какое у него будет API. Либо делает общее, либо распределяет по функционалу или каким-то своим критериям, и в каждое апи добавляет тот набор функций, который ему необходим.  
  

## При чем тут слово «интерфейс»

  

> — Минуточку, Оля! Ты же сама выше писала, что API — это Application programming interface. Почему ты тогда говоришь о контракте, хотя там слово интерфейс?

  
Да потому, что в программировании контракт — это и есть интерфейс. В классическом описании ООП (объектно-ориентированного программирования) есть 3 кита:  
  

1. Инкапсуляция
2. Наследование
3. Полиморфизм

  
Инкапсуляция — это когда мы скрываем реализацию. Для пользователя все легко и понятно. Нажал на кнопочку — получил отчет. А как это работает изнутри — ему все равно. Какая база данных скрыта под капотом? Oracle? MySQL? На каком языке программирования написана программа? Как именно организован код? Не суть. Программа предоставляет интерфейс, им он и пользуется.  
  
Не всегда программа предоставляет именно графический интерфейс. Это может быть SOAP, REST интерфейс, или другое API. Чтобы использовать этот интерфейс, вы должны понимать:  
  

- что подать на вход;
- что получается на выходе;
- какие исключения нужно обработать.

  
Пользователи работают с _GUI — graphical user interface_. Программы работают с _API — Application programming interface_. Им не нужна графика, только контракт.  
  

# Как вызывается API

  
Вызвать апи можно как напрямую, так и косвенно.  
  
Напрямую:  
  

1. Система вызывает функции внутри себя
2. Система вызывает метод другой системы
3. Человек вызывает метод
4. Автотесты дергают методы

  
Косвенно:  
  

1. Пользователь работает с GUI

  

## Вызов API напрямую

  

### 1. Система вызывает функции внутри себя

  
Разные части программы как-то общаются между собой. Они делают это на программном уровне, то есть на уровне API!  
  
Это самый «простой» в использовании способ, потому что автор API, которое вызывается — разработчик. И он же его потребитель! А значит, проблемы с неактуальной документацией нет =)  
  
Шучу, проблемы с документацией есть всегда. Просто в этом случае в качестве документации будут комментарии в коде. А они, увы, тоже бывают неактуальны. Или разработчики разные, или один, но уже забыл, как делал исходное api и как оно должно работать…  
  
  

### 2. Система вызывает метод другой системы

  
А вот это типичный кейс, которые тестируют тестировщики в интеграторах. Или тестировщики, которые проверяют интеграцию своей системы с чужой.  
  
Одна система дергает через api какой-то метод другой системы. Она может попытаться получить данные из другой системы. Или наоборот, отправить данные в эту систему.  
  

> Допустим, я решила подключить [подсказки из Дадаты](https://dadata.ru/suggestions/) к своему интернет-магазинчику, чтобы пользователь легко ввел адрес доставки.  
>   
> Я подключаю подсказки по API. И теперь, когда пользователь начинает вводить адрес на _моем_ сайте, он видит подсказки из _Дадаты_. Как это получается:  
>   
> 
> - Он вводит букву на моем сайте
> - Мой сайт отправляет запрос в подсказки Дадаты по API
> - Дадата возвращает ответ
> - Мой сайт его обрабатывает и отображает результат пользователю
> 
>   
> Вон сколько шагов получилось! И так на каждый введенный символ. Пользователь не видит этого взаимодействия, но оно есть.

  
И, конечно, не забываем про кейс, когда мы разрабатываем именно API-метод. Который только через SOAP и можно вызвать, в интерфейсе его нигде нет. Что Заказчик заказал, то мы и сделали ¯\_(ツ)_/¯  
  

> Пример можно посмотреть в Users. Метод [MagicSearch](https://testbase.atlassian.net/wiki/spaces/USERS/pages/1249378773/MagicSearch) создан на основе реальных событий. Хотя надо признать, в оригинале логика еще замудренее была, я то под свой сайт подстраивала.  
>   
> Но тут фишка в том, что в самой системе в пользовательском интерфейсе есть только обычный поиск, просто строка ввода. Ну, может, парочка фильтров. А вот для интеграции нужна была целая куча доп возможностей, что и было сделано через SOAP-метод.  
>   
> Функционал супер-поиска доступен только по API, пользователь в интерфейсе его никак не пощупает.

  
В этом случае у вас обычно есть ТЗ, согласно которому работает API-метод. Ваша задача — проверить его. Типичная задача тестировщика, просто добавьте к стандартным тестам на тест-дизайн особенности тестирования API, и дело в шляпе!  
  
_(что именно надо тестировать в API — я расскажу отдельной статьей чуть позднее)_  
  
  

### 3. Человек вызывает метод

  
Причины разные:  
  

1. Для ускорения работы
2. Для локализации бага (проблема где? На сервере или клиенте?)
3. Для проверки логики без докруток фронта

  
Если система предоставляет API, обычно проще дернуть его, чем делать то же самое через графический интерфейс. Тем более что вызов API можно сохранить в инструменте. Один раз сохранил — на любой базе применяешь, пусть даже она по 10 раз в день чистится.  
  

> Для примера снова идем в [Users](https://okiseleva.blogspot.com/2017/04/users-soap-rest.html). Если мы хотим создать пользователя, надо заполнить уйму полей!  
>   
> ![image](https://habrastorage.org/r/w1560/webt/0g/ra/yn/0graynfv0qexhh4iubtecyyzepo.png)  
>   
> Конечно, это можно сделать с помощью специальных плагинов типа [Form Filler](https://okiseleva.blogspot.com/2019/04/form-filler.html). Но что, если вам нужны адекватные тестовые данные под вашу систему? И на русском языке?  
>   
> Заполнение полей вручную — грустно и уныло! А уж если это надо повторять каждую неделю или день на чистой тестовой базе — вообще кошмар. Это сразу первый приоритет на автоматизацию рутинных действий.  
>   
> И в данном случае роль автоматизатора выполняет… Postman. Пользователя можно создать через REST-запрос [CreateUser](https://testbase.atlassian.net/wiki/spaces/USERS/pages/871924071/CreateUser). Один раз прописали нормальные “как настоящие” данные, каждый раз пользуемся. Профит!  
>   
> Вместо ручного заполнения формы (1 минута бездумного заполнения полей значениями «лпрулпк») получаем 1 секунду нажатия на кнопку «Send». При этом значения будут намного адекватнее.  
>   
> А еще в постмане можно сделать отдельную папку подготовки тестовой базы, напихать туда десяток запросов. И вот уже на любой базе за пару секунд вы получаете столько данных, сколько вручную вбивали бы часами!

  
Если вы нашли баг и не понимаете, на кого его вешать — разработчика front-end или back-end, уберите все лишнее. Вызовите метод без графического интерфейса. А еще вы можете тестировать логику программы, пока интерфейс не готов или сломан.  
  

### 4. Автотесты дергают методы

  
Есть типичная пирамида автоматизации:  
  

- GUI-тесты — честный тест, «как это делал бы пользователь».
- API-тесты — опускаемся на уровень ниже, выкидывая лишнее.
- Unit-тесты — тесты на отдельную функцию

  
![image](https://habrastorage.org/r/w1560/webt/hp/yc/ng/hpycngdplj56-mdkhf2tropqvhq.png)  
  
Слово API как бы намекает на то, что будет использовано в тестах ツ  
  

> Допустим, у нас есть:  
>   
> 
> - **операция**: загрузка отчета;
> - **на входе**: данные из ручных или автоматических корректировок или из каких-то других мест;
> - **на выходе**: отчет, построенный по неким правилам
> 
>   
> Правила построения отчета:  
>   
> 
> - **Ячейка 1**: Х — Y
> - **Ячейка 2**: Z * 6
> - ...
> 
>   
> ![image](https://habrastorage.org/r/w1560/webt/p-/hw/lf/p-hwlfdcpoxryvrxjvlcg43h7ma.png)  
>   
> **GUI-тесты** — честный тест, робот делает все, что делал бы пользователь. Открывает браузер, тыкает на кнопочки… Но если что-то упадет, будете долго разбираться, где именно.  
>   
> **API-тесты** — все то же самое, только без браузера. Мы просто подаем данные на вход и проверяем данные на выходе. Например, можно внести итоговый ответ в эксельку, и пусть робот выверяет ее, правильно ли заполняются данные? Локализовать проблему становится проще.  
>   
> **Unit-тесты** — это когда мы проверяем каждую функцию отдельно. Отдельно смотрим расчет для ячейки 1, отдельно — для ячейки 2, и так далее. Такие тесты шустрее всего гоняются и баги по ним легко локализовать.

  
  

## Косвенный вызов API

  
Когда пользователь работает с GUI, на самом деле он тоже работает с API. Просто не знает об этом, ему это просто не нужно.  
  
То есть когда пользователь открывает систему и пытается загрузить отчет, ему не важно, как работает система, какой там magic внутри. У него есть кнопочка «загрузить отчет», на которую он и нажимает. Пользователь работает через GUI (графический пользовательский интерфейс).  
  
![image](https://habrastorage.org/r/w1560/webt/-o/7i/b_/-o7ib_j6tnrt1rz3axldz8vqmxq.png)  
  
Но на самом деле под этим графическим пользовательским интерфейсом находится API. И когда пользователь нажимает на кнопочку, кнопочка вызывает функцию построения отчета.  
  
![image](https://habrastorage.org/r/w1560/webt/x3/co/rs/x3corsskpydptgjoaebtgrqvhbi.png)  
  
А функция построения отчета уже может вызывать 10 разных других функций, если ей это необходимо.  
  
И вот уже пользователь видит перед собой готовый отчет. Он вызвал сложное API, даже не подозревая об этом!  
  

# Что значит «Тестирование API»

  
В первую очередь, мы подразумеваем тестирование ЧЕРЕЗ API. «Тестирование API» — общеупотребимый термин, так действительно говорят, но технически термин некорректен. Мы не тестируем API, мы не тестируем GUI (графический интерфейс). Мы тестируем какую-то функциональность через графический или программный интерфейс.  
  
Но это устоявшееся выражение. Можно использовать его и говорить “тестирование API”. И когда мы про это говорим, мы имеем в виду:  
  

- автотесты на уровне API
- или интеграцию между двумя разными системами.

  
Интеграция — когда одна система общается с другой по какому-то протоколу передачи данных. Это называется Remote API, то есть общение по сети, по некоему протоколу (HTTP, JMS и т.д.). В противовес ему есть еще Local API (он же «Shared memory API») — это то API, по которому программа общается сама с собой или общается с другой программой внутри одной виртуальной памяти.  
  
![image](https://habrastorage.org/r/w1560/webt/b3/of/e9/b3ofe9co4ncbwachodnenynwsxu.png)  
  
Когда мы говорим про тестирование API, чаще всего мы подразумеваем тестирование Remote API. Когда у нас есть две системы, находящихся на разных компьютерах, которые как-то между собой общаются.  
  
И если вы видите в вакансии «тестирование API», скорее всего это подразумевает умение вызвать SOAP или REST сервис и протестировать его. Хотя всегда стоит уточнить!  
  

# Резюме

  
_API (Application programming interface)_ — это контракт, который предоставляет программа. «Ко мне можно обращаться так и так, я обязуюсь делать то и это».  
  
Контракт включает в себя:  

- саму операцию, которую мы можем выполнить,
- данные, которые поступают на вход,
- данные, которые оказываются на выходе (контент данных или сообщение об ошибке).

  
Вызвать API можно как напрямую, так и косвенно:  

1. Система вызывает функции внутри себя
2. Система вызывает метод другой системы
3. Человек вызывает метод
4. Автотесты дергают методы
5. Пользователь работает с GUI

  
Когда говорят про API с тестировщиком, обсуждают два варианта:  

- автотесты на уровне API (умение автоматизировать)
- интеграцию между двумя разными системами (обычно SOAP или REST, то есть работу в SOAP Ui или Postman).

  
Если вы хотите отработать второй вариант и поучиться отправлять запросики — используйте бесплатную систему [Users](https://okiseleva.blogspot.com/2017/04/users-soap-rest.html)! И мои обучающие видосики, например, «[Как отправить REST-запрос за 5 минут](https://www.youtube.com/watch?v=U7-8ZmCBiPI&lc=z23qdpgwsv3wxzbsqacdp431jrsmac0ukr1vpbosgz1w03c010c)».