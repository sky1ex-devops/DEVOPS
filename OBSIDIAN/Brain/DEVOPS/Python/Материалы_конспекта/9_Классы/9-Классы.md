[Назад](Конспект_Python.md)

* [[#- Создание класса -]]
* [[#- Изменение значение атрибута с приращением -]]
* [[#- Метод init() класса-потомка -]]
* [[#- Определение атрибутов и методов класса-потомка]]
* [[#- Переопределение методов класса-родителя]]
* [[#- Импортирование классов -]]

___
#### - Создание класса -


>Классы используется для описания существующих предметов и ситуаций для объектов на основе этих ситуаций.
>Другими словами мы определяем общее поведение для целой категории объектов

> Принято называть классы с Заглавной буквы

> Функция являющаяся частью класса, является ***методом***

> Метод\__init__  автоматически выполняется при создании нового объекта

> self - обязательный параметр, ссылка на экземпляр, предоставляет экземпляру доступ к атрибутам и  методам.

```python
class Pin(): # определяем класс с именем Pin
	"""Простая модель пингвина""" # коментарий 

	def __init__(self, name, age): # Метод\__init__  автоматически выполняется
								   # при создании нового объекта
		"""Инициализирует атрибут name и age."""
		self.name = name # Любая переменная с префиксом self
		self.age = age   # Доступна для каждого метода в классе

	def sit(self):       # Создаем метод выводящий текст
		"""Пингвин садится по команде."""
		print(f"{self.name} садится")
  
	def roll_over(self): # Создаем метод выводящий текст
		"""Пингвин перекатывается по команде"""
		print(f"{self.name} Катится!")

my_pin = Pin('Пепе', 6) # Задаем значения
your_pin = Pin('Лоло', 4)

print(f"Моего пингвина зовут {my_pin.name}")
print(f"возраст {my_pin.age} лет")
my_pin.sit() # Вызываем метод
my_pin.roll_over()

print(f"Моего пингвина зовут {your_pin.name}")
print(f"возраст {your_pin.age} лет")
my_pin.sit()
```


```python

class Car():
    """Простая модель автомобиля"""

    def __init__(self, make, model, year):
        """Инициализирует атребуты описания автомобиля"""
        self.make = make
        self.model = model
        self.year = year
        self.odom = 0

    def get_descriptive_name(self):
        """Возвращает отфарматированиое описание"""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()
    
    def read_odometer(self):
        """Выводит пробег машины"""
        print(f"Машина проехала {self.odom} км")

my_new_car = Car('audi', 'a4', 2019)
print(my_new_car.get_descriptive_name())
my_new_car.odom = 23
my_new_car.read_odometer()

```

####  - Изменение значение атрибута с приращением -

```python

class Car():
    """Простая модель автомобиля"""

    def __init__(self, make, model, year):
        """Инициализирует атребуты описания автомобиля"""
        self.make = make
        self.model = model
        self.year = year
        self.odom = 0

    def get_descriptive_name(self):
        """Возвращает отфарматированиое описание"""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()
    
    def read_odometer(self):
        """Выводит пробег машины"""
        print(f"Машина проехала {self.odom} км")

    def update_odometer(self, klm):
        """Заданное значение га одометре.
        при попытке обратной подкрутки
        изменения отклоняются"""
        if klm >= self.odom:
            self.odom = klm
        else:
            print("Не верное значение км.")

    def increment_odom(self, klm): # Получаем расстояние и прибавляем 
        """Увеличение показания одометра с заданным приращиванием"""
        self.odom += klm           # к self.odom

my_used_car = Car('subaru', 'outbask', 2015) # Создаем экземпляр my_used_car 
print(my_used_car.get_descriptive_name())    
my_used_car .update_odometer(56000)   # передаем показания одометра методом
									  # my_used_car
my_used_car .read_odometer()          

my_used_car .increment_odom(250)  # вызываем метод increment_odom, передаем
my_used_car .read_odometer()  # значение 250, что бы увеличить показания на 250

my_new_car = Car('audi', 'a4', 2019)
print(my_new_car.get_descriptive_name())
my_new_car.update_odometer(25)
my_new_car.read_odometer()

```

#### - Метод init() класса-потомка -

 > Дает возможность не писать новый класс с нуля.
 > При создании класса потомка, для него становятся доступны атрибуты родителя.
  
> Для создания класса потомка, класс родитель должен быть частью текущего файла

> В определении класса потомка - класс родитель заключается в () скобки

```python

class Car(): # Класс родитель
    """Простая модель автомобиля"""

    def __init__(self, make, model, year):
        """Инициализирует атребуты описания автомобиля"""
        self.make = make
        self.model = model
        self.year = year
        self.odom = 0

    def get_descriptive_name(self):
        """Возвращает отфарматированиое описание"""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()
    
    def read_odometer(self):
        """Выводит пробег машины"""
        print(f"Машина проехала {self.odom} км")

    def update_odometer(self, klm):
        """Заданное значение га одометре.
        при попытке обратной подкрутки
        изменения отклоняются"""
        if klm >= self.odom:
            self.odom = klm
        else:
            print("Не верное значение км.")

    def increment_odom(self, klm):
        """Увеличение показания одометра с заданным приращиванием"""
        self.odom += klm

class ElCar(Car): # Определяется класс потомка
    """Предоставляет аспекты машины, специфические для электромобиля"""

    def __init__(self, make, model, year):
        """инициализация атрибутов класс-родителя"""
        super().__init__(make, model, year) # super() - специальная функция
        # позволяющая вызвать метод родительского класса.
        self.battery_size = 75

    def describe_battery(self):
        """Выводит информацию о мощности АКБ"""
        print(f"This car has a {self.battery_size} -kwh")
    

my_used_car = Car('subaru', 'outbask', 2015)
print(my_used_car.get_descriptive_name())
my_used_car .update_odometer(56000)
my_used_car .read_odometer()

my_used_car .increment_odom(250)
my_used_car .read_odometer()

print("\n")
my_new_car = Car('audi', 'a4', 2019)
print(my_new_car.get_descriptive_name())
my_new_car.update_odometer(25)
my_new_car.read_odometer()

print("\n")
my_tesla = ElCar('tesla', 'model s', 2019)
print(my_tesla.get_descriptive_name())
my_tesla.describe_battery()
print("\n")

```

#### - Определение атрибутов и методов класса-потомка

```python

class Car():
    """Простая модель автомобиля"""

    def __init__(self, make, model, year):
        """Инициализирует атребуты описания автомобиля"""
        self.make = make
        self.model = model
        self.year = year
        self.odom = 0

    def get_descriptive_name(self):
        """Возвращает отфарматированиое описание"""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()
    
    def read_odometer(self):
        """Выводит пробег машины"""
        print(f"Машина проехала {self.odom} км")

    def update_odometer(self, klm):
        """Заданное значение га одометре.
        при попытке обратной подкрутки
        изменения отклоняются"""
        if klm >= self.odom:
            self.odom = klm
        else:
            print("Не верное значение км.")

    def increment_odom(self, klm):
        """Увеличение показания одометра с заданным приращиванием"""
        self.odom += klm

class Battery():
    """Простая модель аккумулятора элктромобиля"""
    def __init__(self, battery_size=75):
        """Инициализация атрибутов АКБ"""
        self.battery_size = battery_size
    
    def describe_battery(self):  # Добавляем новые методы
        """Выводит информацию о мощьности АКБ"""
        print(f"This car has a {self.battery_size} -kwh")

    def get_range(self): # Добавляем новые методы
        """Выводит приблизительный запас хода"""
        if self.battery_size == 75: #  Добавляем новые атрибуты
            range = 260
        elif self.battery_size == 100:
            range = 315

        print(f"This car can go about {range} klm on a full charge")

class ElCar(Car):
    """Предоставляет аспекты машины, специфические для электромобиля"""

    def __init__(self, make, model, year):
        """инициализация атрибутов класс-родителя"""
        super().__init__(make, model, year)
        self.battery = Battery()

    def describe_battery(self):
        """Выводит информацию о мощности АКБ"""
        print(f"This car has a {self.battery_size} -kwh")
    
    def fill_gas_tank(self):
        """У электромобиля нет бинзобака"""
        print("This car doesn't need a gas tank")

my_used_car = Car('subaru', 'outbask', 2015)
print(my_used_car.get_descriptive_name())
my_used_car .update_odometer(56000)
my_used_car .read_odometer()

my_used_car .increment_odom(250)
my_used_car .read_odometer()

print("\n")
my_new_car = Car('audi', 'a4', 2019)
print(my_new_car.get_descriptive_name())
my_new_car.update_odometer(25)
my_new_car.read_odometer()

print("\n")
my_tesla = ElCar('tesla', 'model s', 2019)
print(my_tesla.get_descriptive_name())
my_tesla.battery.describe_battery() # Обращаемся к my_tesla, находим атрибут battery
                                    #  и вызываем метод describe_battery
my_tesla.battery.get_range()
print("\n")

```

#### - Переопределение методов класса-родителя

> Метод родительского класса можно переопределить, если в моделируемой ситуации
> он делает не то что нужно.

```python

"""Класс для представления автомобиля"""
class Car():
    """Простая модель автомобиля"""

    def __init__(self, make, model, year):
        """Инициализирует атребуты описания автомобиля"""
        self.make = make
        self.model = model
        self.year = year
        self.odom = 0

    def get_descriptive_name(self):
        """Возвращает отфарматированиое описание"""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()
    
    def read_odometer(self):
        """Выводит пробег машины"""
        print(f"Машина проехала {self.odom} км")

    def update_odometer(self, klm):
        """Заданное значение га одометре.
        при попытке обратной подкрутки
        изменения отклоняются"""
        if klm >= self.odom:
            self.odom = klm
        else:
            print("Не верное значение км.")

    def increment_odom(self, klm):
        """Увеличение показания одометра с заданным приращиванием"""
        self.odom += klm

class Battery():
    """Простая модель аккумулятора элктромобиля"""
    def __init__(self, battery_size=75):
        """Инициализация атрибутов АКБ"""
        self.battery_size = battery_size
    
    def describe_battery(self):
        """Выводит информацию о мощьности АКБ"""
        print(f"This car has a {self.battery_size} -kwh")

    def get_range(self):
        """Выводит приблизительный запас хода"""
        if self.battery_size == 75:
            range = 260
        elif self.battery_size == 100:
            range - 315

        print(f"This car can go about {range} klm on a full charge")

class ElCar(Car):
    """Предоставляет аспекты машины, специфические для электромобиля"""

    def __init__(self, make, model, year):
        """инициализация атрибутов класс-родителя"""
        super().__init__(make, model, year)
        self.battery = Battery()

    def describe_battery(self):
        """Выводит информацию о мощности АКБ"""
        print(f"This car has a {self.battery_size} -kwh")
    
    def fill_gas_tank(self): # Если будет вызван метод fill_gas_tank для Эл.моб.,
    # тогда метод fill_gas_tank класса Car будет проигнорирован. 
        """У электромобиля нет бинзобака""" 
        print("This car doesn't need a gas tank")

```

#### - Импортирование классов -

 > Можно вынести модули в отдельный файл.
 > в этом случае в файле программы останется только код с вызовом методов 
 
 ```python
rom car import Car, ElCar # импортируем класс Car и ElCar
from car # Импортируем весть модуль
from car import * # импорт всех классов
# Также можно импортировать классы из модуля в модуль from car import car
# Можно использовать псевданимы from car import Car as MC
print("\n")
my_new_car = Car('audi', 'a4', 2019)
print(my_new_car.get_descriptive_name())
my_new_car.update_odometer(25)
my_new_car.read_odometer()
```



___
[Назад](Конспект_Python.md)